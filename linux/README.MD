# 名词：
* 保护模式
* 分段机制
* 分页机制
* 段地址
* 线性地址
* 中断门
* 局部描述符
* 全局描述符

## 为什么简单的地址机制，设计得如此复杂。
这些机制的原因都有它的缘由，任何复杂的设计都是由一个简单的设计发展起来的，当简单的设计满足不了实际需要时，就会一步一步地革新，直到问题被圆满地解决。

## 1.1 保护模式
### 1.1.1 分页机制
#### 问题
早期程序使用物理地址，很可能有多个起始地址一致的应用程序需要同时被加载运行，这就需要把冲突的程序加载到另外的地址上去。然而早期的计算机内存有限，能够同时加载运行的程序有限。

#### 解决办法——大致思想
在多任务系统上，某些进程在部分时间内处于等待状态，自然想到，当内存不够的时候把处于等待状态的进程换入磁盘，腾出一些内存空间来加载新程序。

然而，每次腾出来的空间地址不是固定的，这意味着磁盘上的内容加载进来的时候，又要重新修正程序中的相关地址，在每次换入换出时，要不断修正相关程序的地址。而且还有一个更为严重的问题：假设进程A出现一个错误，对某个物理地址进行了写入操作，恰好这个地址又属于进程B，当进程B被调度运行时，必然出现错误。于是虚拟内存技术发展起来

#### 具体操作方法
32位系统为例，每一个进程有4GB的虚拟地址空间，每个进程有一个表，记录着每个虚拟地址对应的物理地址是多少，这样当程序加载的时候，可以先分配好物理内存，然后把物理内存的地址填入到这个表里面，这样进程之间互不影响。

假设程序A和B都是要求地址BASE处加载，由于每个进程都有4GB的私有虚拟地址空间，因此两个进程没有加载冲突。当进程A访问虚拟地址BASE+X的时候，由于MMU的硬件支持，硬件自动查找进程A的地址映射表，从而访问到物理地址A1+X的内存单元。同理，当进程B访问虚拟地址BASE+X的时候，MMU自动查找进程B的地址映射表，从而访问到B1+X的内存单元。

#### 初步内存映射
每个进程拥有4GB的虚拟地址空间，每个字节的虚拟地址可以通过地址映射表映射到一个字节的物理地址上面去。因此这个映射表本身必然要占据很大的内存空间。如果在虚拟地址映射表中为每个字节建立映射关系，那么映射4GB的虚拟地址需要2^30 * 4B(32位系统地址为4Byte)的内存，反而更浪费内存。

所以所有操作系统都采用了页式管理。把物理内存划分为4KB，8KB或者16KB大小的页，这样每个页面在虚拟映射表中仅仅占用4Byte的内存。以4KB的页大小为例，4GB的虚拟地址空间有2^20个页面，那么映射4GB空间的映射表仅仅需要2^20 * 4B的内存。

原理如下：程序需要访问地址0x12345A10，CPU中的MMU首先找到这个进程的虚拟地址映射表，其起始物理地址为0x10000000，在4KB页大小的情况下，4GB虚拟地址空间含有2^20个页面，只需要20位就可以表示2^20的大小了，所以虚拟地址的高20位0x12345作为虚地址映射表中的索引，在32位系统上虚地址映射表中的每一项都是4字节，所以MMU根据地址0x100000000+0x12345*4取得虚拟地址0x12345A10对应的物理页面起始地址为0x54321000，该地址的低12位总是为0，这是由于每一个4KB大小的物理页面总是4KB的边界上对齐的。而虚地址0x12345A10中的低12位被用作页内偏移量，最终虚地址0x12345A10对应的物理地址为0x54321A10，而CPU访问到的内容是0x12345678.

补充：由于页大小为4KB，虚拟地址表的低12位总是0，因此可以把低12位用来做标识位。例如把第0位用作存在位，当第0位为1时，表示该页面在物理内存中，反之表示该页面不在物理内存中。假设一个进程要占用10MB的内存空间，在进程初始化的时候，虚地址映射表初始化为0，在内存不足的情况下，系统只分配了5MB的内存，这5MB内存的物理地址被填入到映射表中，同时表项中最低位被设置为1，当进程访问到另外5MB的虚地址的时候，MMU在查表时发现最低位为0，于是触发一个缺页中断，这个时候，系统缺页中断处理里程再分配内存页面，同时更新相应的映射表象，之后程序就可以正常运行了。

补充：还可以划分一位作为读写位，如果对一个地址进行写入操作，MMU在查表的时候回根据其读写位判断是否允许写入。NULL指针是最好的范例，为什么操作系统能够捕捉这个错误呢？地址0肯定对应了内存中的一个物理地址，那么如何根据一个地址来判断指针是否合法呢？实际上，所有操作系统都保证了一个进程中虚拟地址从0开始的某个区域是不映射的，其页表项为0。因此访问NULL指针必然触发缺页中断，这时操作系统就可以判断这个地址是否可操作。

补充：另外，windows、linux等操作系统都有一个文件映射技术，可以把一个大小远超过物理内存的文件映射到进程的虚地址空间X起始处，之后程序通过访问数组的方式来访问文件的内容。由于物理内存小于文件大小，所以内核只读入一部分的文件内容，并建立映射，当访问到没有被映射的部分的时候就会触发缺页中断，这个时候中断处理例程会再分配一定的物理内存页面，然后把它映射到访问的地方。这个过程对程序来说是透明的，程序根本不用关心系统物理内存到底有多大。

还可以通过把同一物理页面映射到不同的进程的虚拟地址空间中去来实现内存共享，无论各个进程映射的虚拟地址是相同还是不同的，访问到的都是同一个物理页面。在操作系统中有一个重要的Copy-On-Write机制，多个进程共享同一片内存，这片内存的读写位被设置为0，当某个进程对齐写入的时候，触发中断，在中断出力程序中，把要写入的相关页面复制一份，之后该进程单独使用这些内存，而进程间仍然使用共享的内存。

#### 内存映射的硬件支持
虚地址到物理的转换过程是由硬件自动完成的。由于虚地址映射表是进程私有的，因此各个进程的虚地址映射表被放在不同的物理内存中，而且每个进程都必须把这个表的起始地址告诉MMU，这就是Page Table Start Address的作用，很容易想到这个地址必须是物理地址。

#### 内存的再次优化————二级页表
前面说过虚地址映射表的大小为4MB，在虚地址的高20位是这个表中的索引，这意味着这4MB空间必须作为进程的必备资源在启动的时候一次分配，而且这4MB的内存必须在物理地址上是连续的。这可不是一个好消息，想想内存的设计理念就是在一个小内存系统上运行尽可能多的程序，而这个限制将导致一个配备64M内存的系统运行不了几个进程。考虑到一个进程不需要同时访问到4GB的内存，因此映射表可以被分散开来，像物理内存那样在需要的时候再分配。于是两级、三级甚至4级页表的概念被提出来。

以32位X86系统为例：地址映射表分为两级，第一级被称为页目录表，第二级为页表，每个进程的页目录表起始物理地址由CPU中的寄存器CR3指定，而虚拟地址的最高10位将作为页目录的索引，CR3+（页目录索引*4）就可以得到PDE。PDE的高20位指定一个页表的起始地址，低12位是一些标志位，同时虚拟地址的中间10位被用作页表的索引，从而得到PTE。PTE的高20位指定了一个4KB页面的起始地址，而虚拟地址的最低12位被用作页内偏移量，从而访问到虚拟地址指定的内存单元。最高10位用作页目录的索引，每项4字节，所以页目录大小正好4KB，1024项，每一项指向一个页表，每个页表又有1024项指向对应的4KB页，总共可以映射的内存就是4GB。这样一来，一个进程的页表就可以被分散开来，在页目录索引时，如果发现页表没有被映射，就可以通过缺页中断来分配并建立新的映射。

两级页表虽然能解决一次要连续分配4MB页表的问题，但是每次访问内存都需要两次查表才能得到物理地址，最后才能访问到指定的内存，这样就降低了内存的访问速度，为此CPU内部设置了最近存取的页面的缓存，称为TLB，即程序先到TLB中查找，没有再访问二级页表，从而极大提高访问速度。

#### 内存的继续优化
至此，每一个进程都有独立的页表，进程总是通过查本进程页表来获取物理地址，因此无法直接修改其他进程的内存。这样一来，进程就被保护起来而不受其他进程的影响了。这是保护模式的一个重要特征，但是这样的保护还是不够的。我们知道几乎每一个进程都要通过操作系统提供的接口执行一些操作系统内核提供的代码。例如进程通过read系统调用读取文件内容，而具体读取文件的代码则是操作系统内核提供的，同时内核的这些代码也需要使用一些数据，这部分代码和数据必须映射到每一个进程的地址空间中，但是如果任何一个进程有意或无意地修改了这部分代码或数据的话，后果是很严重的。

### 1.1.2 分段机制
