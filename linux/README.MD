# 名词：
* 保护模式
* 分段机制
* 分页机制
* 段地址
* 线性地址
* 中断门
* 局部描述符
* 全局描述符

## 为什么简单的地址机制，设计得如此复杂。
这些机制的原因都有它的缘由，任何复杂的设计都是由一个简单的设计发展起来的，当简单的设计满足不了实际需要时，就会一步一步地革新，直到问题被圆满地解决。

## 1.1 保护模式
### 1.1.1 分页机制
#### 问题
早期程序使用物理地址，很可能有多个起始地址一致的应用程序需要同时被加载运行，这就需要把冲突的程序加载到另外的地址上去。然而早期的计算机内存有限，能够同时加载运行的程序有限。

#### 解决办法——大致思想
在多任务系统上，某些进程在部分时间内处于等待状态，自然想到，当内存不够的时候把处于等待状态的进程换入磁盘，腾出一些内存空间来加载新程序。

然而，每次腾出来的空间地址不是固定的，这意味着磁盘上的内容加载进来的时候，又要重新修正程序中的相关地址，在每次换入换出时，要不断修正相关程序的地址。而且还有一个更为严重的问题：假设进程A出现一个错误，对某个物理地址进行了写入操作，恰好这个地址又属于进程B，当进程B被调度运行时，必然出现错误。于是虚拟内存技术发展起来

#### 具体操作方法
32位系统为例，每一个进程有4GB的虚拟地址空间，每个进程有一个表，记录着每个虚拟地址对应的物理地址是多少，这样当程序加载的时候，可以先分配好物理内存，然后把物理内存的地址填入到这个表里面，这样进程之间互不影响。

假设程序A和B都是要求地址BASE处加载，由于每个进程都有4GB的私有虚拟地址空间，因此两个进程没有加载冲突。当进程A访问虚拟地址BASE+X的时候，由于MMU的硬件支持，硬件自动查找进程A的地址映射表，从而访问到物理地址A1+X的内存单元。同理，当进程B访问虚拟地址BASE+X的时候，MMU自动查找进程B的地址映射表，从而访问到B1+X的内存单元。

#### 初步内存映射
每个进程拥有4GB的虚拟地址空间，每个字节的虚拟地址可以通过地址映射表映射到一个字节的物理地址上面去。因此这个映射表本身必然要占据很大的内存空间。如果在虚拟地址映射表中为每个字节建立映射关系，那么映射4GB的虚拟地址需要2^30 * 4B(32位系统地址为4Byte)的内存，反而更浪费内存。

所以所有操作系统都采用了页式管理。把物理内存划分为4KB，8KB或者16KB大小的页，这样每个页面在虚拟映射表中仅仅占用4Byte的内存。以4KB的页大小为例，4GB的虚拟地址空间有2^20个页面，那么映射4GB空间的映射表仅仅需要2^20 * 4B的内存。

原理如下：程序需要访问地址0x12345A10，CPU中的MMU首先找到这个进程的虚拟地址映射表，其起始物理地址为0x10000000，在4KB页大小的情况下，4GB虚拟地址空间含有2^20个页面，只需要20位就可以表示2^20的大小了，所以虚拟地址的高20位0x12345作为虚地址映射表中的索引，在32位系统上虚地址映射表中的每一项都是4字节，所以MMU根据地址0x100000000+0x12345*4取得虚拟地址0x12345A10对应的物理页面起始地址为0x54321000，该地址的低12位总是为0，这是由于每一个4KB大小的物理页面总是4KB的边界上对齐的。而虚地址0x12345A10中的低12位被用作页内偏移量，最终虚地址0x12345A10对应的物理地址为0x54321A10，而CPU访问到的内容是0x12345678.

补充：由于页大小为4KB，虚拟地址表的低12位总是0，因此可以把低12位用来做标识位。例如把第0位用作存在位，当第0位为1时，表示该页面在物理内存中，反之表示该页面不在物理内存中。假设一个进程要占用10MB的内存空间，在进程初始化的时候，虚地址映射表初始化为0，在内存不足的情况下，系统只分配了5MB的内存，这5MB内存的物理地址被填入到映射表中，同时表项中最低位被设置为1，当进程访问到另外5MB的虚地址的时候，MMU在查表时发现最低位为0，于是触发一个缺页中断，这个时候，系统缺页中断处理里程再分配内存页面，同时更新相应的映射表象，之后程序就可以正常运行了。

补充：还可以划分一位作为读写位，如果对一个地址进行写入操作，MMU在查表的时候回根据其读写位判断是否允许写入。NULL指针是最好的范例，为什么操作系统能够捕捉这个错误呢？地址0肯定对应了内存中的一个物理地址，那么如何根据一个地址来判断指针是否合法呢？实际上，所有操作系统都保证了一个进程中虚拟地址从0开始的某个区域是不映射的，其页表项为0。因此访问NULL指针必然触发缺页中断，这时操作系统就可以判断这个地址是否可操作。

补充：另外，windows、linux等操作系统都有一个文件映射技术，可以把一个大小远超过物理内存的文件映射到进程的虚地址空间X起始处，之后程序通过访问数组的方式来访问文件的内容。由于物理内存小于文件大小，所以内核只读入一部分的文件内容，并建立映射，当访问到没有被映射的部分的时候就会触发缺页中断，这个时候中断处理例程会再分配一定的物理内存页面，然后把它映射到访问的地方。这个过程对程序来说是透明的，程序根本不用关心系统物理内存到底有多大。

还可以通过把同一物理页面映射到不同的进程的虚拟地址空间中去来实现内存共享，无论各个进程映射的虚拟地址是相同还是不同的，访问到的都是同一个物理页面。在操作系统中有一个重要的Copy-On-Write机制，多个进程共享同一片内存，这片内存的读写位被设置为0，当某个进程对齐写入的时候，触发中断，在中断出力程序中，把要写入的相关页面复制一份，之后该进程单独使用这些内存，而进程间仍然使用共享的内存。

#### 内存映射的硬件支持
虚地址到物理的转换过程是由硬件自动完成的。由于虚地址映射表是进程私有的，因此各个进程的虚地址映射表被放在不同的物理内存中，而且每个进程都必须把这个表的起始地址告诉MMU，这就是Page Table Start Address的作用，很容易想到这个地址必须是物理地址。

#### 内存的再次优化————二级页表
前面说过虚地址映射表的大小为4MB，在虚地址的高20位是这个表中的索引，这意味着这4MB空间必须作为进程的必备资源在启动的时候一次分配，而且这4MB的内存必须在物理地址上是连续的。这可不是一个好消息，想想内存的设计理念就是在一个小内存系统上运行尽可能多的程序，而这个限制将导致一个配备64M内存的系统运行不了几个进程。考虑到一个进程不需要同时访问到4GB的内存，因此映射表可以被分散开来，像物理内存那样在需要的时候再分配。于是两级、三级甚至4级页表的概念被提出来。

以32位X86系统为例：地址映射表分为两级，第一级被称为页目录表，第二级为页表，每个进程的页目录表起始物理地址由CPU中的寄存器CR3指定，而虚拟地址的最高10位将作为页目录的索引，CR3+（页目录索引*4）就可以得到PDE。PDE的高20位指定一个页表的起始地址，低12位是一些标志位，同时虚拟地址的中间10位被用作页表的索引，从而得到PTE。PTE的高20位指定了一个4KB页面的起始地址，而虚拟地址的最低12位被用作页内偏移量，从而访问到虚拟地址指定的内存单元。最高10位用作页目录的索引，每项4字节，所以页目录大小正好4KB，1024项，每一项指向一个页表，每个页表又有1024项指向对应的4KB页，总共可以映射的内存就是4GB。这样一来，一个进程的页表就可以被分散开来，在页目录索引时，如果发现页表没有被映射，就可以通过缺页中断来分配并建立新的映射。

两级页表虽然能解决一次要连续分配4MB页表的问题，但是每次访问内存都需要两次查表才能得到物理地址，最后才能访问到指定的内存，这样就降低了内存的访问速度，为此CPU内部设置了最近存取的页面的缓存，称为TLB，即程序先到TLB中查找，没有再访问二级页表，从而极大提高访问速度。

#### 内存的继续优化
至此，每一个进程都有独立的页表，进程总是通过查本进程页表来获取物理地址，因此无法直接修改其他进程的内存。这样一来，进程就被保护起来而不受其他进程的影响了。这是保护模式的一个重要特征，但是这样的保护还是不够的。我们知道几乎每一个进程都要通过操作系统提供的接口执行一些操作系统内核提供的代码。例如进程通过read系统调用读取文件内容，而具体读取文件的代码则是操作系统内核提供的，同时内核的这些代码也需要使用一些数据，这部分代码和数据必须映射到每一个进程的地址空间中，但是如果任何一个进程有意或无意地修改了这部分代码或数据的话，后果是很严重的。

### 1.1.2 分段机制
仅仅是分页机制就能够满足虚拟内存管理和保护模式的要求了，现在某些架构的处理器完全不使用分段机制，如MIPS。段机制实际上是x86的一个历史遗留问题，Linux内核也是尽量不使用段机制。Intel在16位处理器时代，由于16位地址线只支持64KB的内存寻址，但是64KB的内存显得太少了。于是提出了分段机制，地址由段基址和偏移组成，用BASE：OFFSET表示，而物理地址由BASE<<4+OFFSET形成。BASE和OFFSET都是16位，OFFSET是段内偏移，因此一个段最多有64KB，而1MB内存最多有16个段，如果使用两个16位的地址分别作为高16位和低16位地址的话，一共是32位，可以最大寻址4GB内存，但是从当时的软硬件条件来看，没有必要这么做。

随着操作系统的发展，提出了保护模式和虚拟内存管理，Intel在分段机制的基础上实现保护模式和虚拟内存管理。后来更为优越的分页机制逐步占据了主流，但是Intel采用分页机制的同时，处于兼容的目的而保留了分段机制。

但此时16位的段寄存器已经不能作为32位系统的段基址，于是段寄存器被用作选择子。而段基址以及段的一些其他属性被存放在一片内存中，被称为段描述符表。为什么不直接将段寄存器也扩充位32位或者更长的呢？因为x86允许不使用分页机制的同时，也能实现保护模式和虚拟内存管理的需要。因此段的基本信息除了段基址外，还需要类似分页机制中页表项中的一些标志位，于是出现了段描述符表。表中的每一项占8字节，它定义了一个段的基本属性。描述符格式如下：
* Segment Base 0-31位表示一个段的起始地址；
* Segment Limit 0-19位表示一个段的最大长度；
* Byte5的最低位A为0，表示本段还从未被访问过，为1表示本段已经被访问过；
* Byte5的ED位表示段的增长方向，ED=0：段地址增长方向是向上的，也就是说从Base开始到Base+Limit这段区间属于本段的。ED=1：段地址增长方向是向下的，也就是说本段的地址空间从Base开始到Base-Limit结束。通常堆栈段是向下增长的；
* Byte5中的E位表示可执行位，当E=1时，表示代码段，E=0表示数据段；
* Byte5中RW为读写位，在数据段中（E=0），RW=0表示该段不能被写入，RW=1表示本段可以被写入；在代码段中，ED=0表示忽略特权级别，ED=1表示遵守特权级别，RW=0，段不可读，RW=1，可读。
* Byte5中的第4位S=1，表示代码段或者数据段，堆栈段也是数据段。S=0，表示系统段，例如终端们，调用门。
* Byte5中的DPL占两位，00～11分别表示访问本段所需要的特权级别，只有级别大于等于DPL中指定的权限才能访问本段。0是最大权限。
* Byte5中的P位表示本段不在内存中，当段内的内存被换入磁盘时可以设置为0，访问这样的段时将触发中断。
* Byte6的第4位保留给系统软件使用。
* Byte6的第5位保留位，总为0。
* Byte6的第6位，DB=0，表示默认地址和操作数是16位，DB=1表示默认地址和操作数是32位。
* Byte6的第7位G=0，表示20位的段界限的单位是字节，这样一个段的最大长度是1M，G=1表示20段界限的单位是4K，这样段的最大长度是4G。

综述：上面许多属性的作用和页表项中重复，实际上在x86上抛开分页机制，也能实现保护模式的各种功能。系统中每一个段都由一个段描述符来表示，这些描述符依次存放在描述符表中，系统中描述符表分全局描述符表和局部描述符表：
* 全局描述符表GDT

CPU内部寄存器GDTR的高32位指向该表的起始地址，低16位表示全局描述符表的界限，界限以字节位单位，低16位可以表示65535个字节，而每一个段描述符表项有8个字节，因此全局描述符表最多有8192项。汇编指令LGDT把一个48位的内存操作数加载到GDTR寄存器中，而SGDT把GDTR保存到一个48位的内存操作数中。

* 局部描述符表LDT

由LDTR寄存器指定。由于Intel的设计本意是每个进程有自己的局部描述符表，因此描述符表的位置不是固定的，它需要随着进程的切换而切换，可能是考虑到进程A切换到进程B的时候，A把自己的LDTR保存在自己的进程地址空间中，之后且还到进程B，再切换回A的时候，由于保护模式下的地址空间隔离，进程B不能恢复A的LDTR，所以进程的LDTR必须保存在全局共享的内存中。于是Intel把每一个局部描述表的首地址放到全局描述表中，这样通过16位的LDTR寄存器在GDT的索引得到一个段描述符表项，改描述符的基地址部分指定了一个局部描述符的起始地址，在这个局部描述符表中又有许多局部描述符表想。其访问过程如下：16位的寄存器LDTR是一个GDT中的索引，实际的LDT由GDT中的一个64位的表项来描述。这样一来每次访问LDT都要查两次表，为了节省开销，LDTR寄存器包含软件可见的16位和软件不可见的64位，LLDT指令的16位操作数作为索引，在GDT中找到64位的一个表项，然后加载到LDTR不可见的部分。

在32位CPU上，段寄存器CS，DS，ES，SS，FS，GS仍然是16位的，被用作全局段描述符和局部段描述符的索引，被称为段选择子，其格式如下：
* 第0位和第1位表示Request Privilege Level，0~3分别代表3个不同的请求级别，最高13位是索引位，可以表示8192项，当TI=1时，表示从局部描述符表选择相应的描述符；TI=0时，从全局描述符表中选择相应的描述符。当CPU通过DS：Offset访问内存的过程是：
1. 如果TI=0，根据GDTR寄存器指定的首地址找到全局描述符表，再利用DS的高13位为索引找到对应的描述符表项，在通过相应的权限检查后，从表项中取出32的段地址，最后再加上Offset从而形成线性地址，如果分页机制开启，该地址还要经过分页机制处理，最后得到物理地址。
