# 名词：
* 保护模式
* 分段机制
* 分页机制
* 段地址
* 线性地址
* 中断门
* 局部描述符
* 全局描述符

## 为什么简单的地址机制，设计得如此复杂。
这些机制的原因都有它的缘由，任何复杂的设计都是由一个简单的设计发展起来的，当简单的设计满足不了实际需要时，就会一步一步地革新，直到问题被圆满地解决。

## 1.1 保护模式
### 1.1.1 分页机制
#### 问题
早期程序使用物理地址，很可能有多个起始地址一致的应用程序需要同时被加载运行，这就需要把冲突的程序加载到另外的地址上去。然而早期的计算机内存有限，能够同时加载运行的程序有限。

#### 解决办法——大致思想
在多任务系统上，某些进程在部分时间内处于等待状态，自然想到，当内存不够的时候把处于等待状态的进程换入磁盘，腾出一些内存空间来加载新程序。

然而，每次腾出来的空间地址不是固定的，这意味着磁盘上的内容加载进来的时候，又要重新修正程序中的相关地址，在每次换入换出时，要不断修正相关程序的地址。而且还有一个更为严重的问题：假设进程A出现一个错误，对某个物理地址进行了写入操作，恰好这个地址又属于进程B，当进程B被调度运行时，必然出现错误。于是虚拟内存技术发展起来

#### 具体操作方法
32位系统为例，每一个进程有4GB的虚拟地址空间，每个进程有一个表，记录着每个虚拟地址对应的物理地址是多少，这样当程序加载的时候，可以先分配好物理内存，然后把物理内存的地址填入到这个表里面，这样进程之间互不影响。

假设程序A和B都是要求地址BASE处加载，由于每个进程都有4GB的私有虚拟地址空间，因此两个进程没有加载冲突。当进程A访问虚拟地址BASE+X的时候，由于MMU的硬件支持，硬件自动查找进程A的地址映射表，从而访问到物理地址A1+X的内存单元。同理，当进程B访问虚拟地址BASE+X的时候，MMU自动查找进程B的地址映射表，从而访问到B1+X的内存单元。

#### 初步内存映射
每个进程拥有4GB的虚拟地址空间，每个字节的虚拟地址可以通过地址映射表映射到一个字节的物理地址上面去。因此这个映射表本身必然要占据很大的内存空间。如果在虚拟地址映射表中为每个字节建立映射关系，那么映射4GB的虚拟地址需要2^30 * 4B(32位系统地址为4Byte)的内存，反而更浪费内存。

所以所有操作系统都采用了页式管理。把物理内存划分为4KB，8KB或者16KB大小的页，这样每个页面在虚拟映射表中仅仅占用4Byte的内存。以4KB的页大小为例，4GB的虚拟地址空间有2^20个页面，那么映射4GB空间的映射表仅仅需要2^20 * 4B的内存。

原理如下：程序需要访问地址0x12345A10，CPU中的MMU首先找到这个进程的虚拟地址映射表，其起始物理地址为0x10000000，在4KB页大小的情况下，4GB虚拟地址空间含有2^20个页面，只需要20位就可以表示2^20的大小了，所以虚拟地址的高20位0x12345作为虚地址映射表中的索引，在32位系统上虚地址映射表中的每一项都是4字节，所以MMU根据地址0x100000000+0x12345*4取得虚拟地址0x12345A10对应的物理页面起始地址为0x54321000，该地址的低12位总是为0，这是由于每一个4KB大小的物理页面总是4KB的边界上对齐的。而虚地址0x12345A10中的低12位被用作页内偏移量，最终虚地址0x12345A10对应的物理地址为0x54321A10，而CPU访问到的内容是0x12345678.

补充：由于页大小为4KB，虚拟地址表的低12位总是0，因此可以把低12位用来做标识位。例如把第0位用作存在位，当第0位为1时，表示该页面在物理内存中，反之表示该页面不在物理内存中。假设一个进程要占用10MB的内存空间，在进程初始化的时候，虚地址映射表初始化为0，在内存不足的情况下，系统只分配了5MB的内存，这5MB内存的物理地址被填入到映射表中，同时表项中最低位被设置为1，当进程访问到另外5MB的虚地址的时候，MMU在查表时发现最低位为0，于是触发一个缺页中断，这个时候，系统缺页中断处理里程再分配内存页面，同时更新相应的映射表象，之后程序就可以正常运行了。

补充：还可以划分一位作为读写位，如果对一个地址进行写入操作，MMU在查表的时候回根据其读写位判断是否允许写入。NULL指针是最好的范例，为什么操作系统能够捕捉这个错误呢？地址0肯定对应了内存中的一个物理地址，那么如何根据一个地址来判断指针是否合法呢？实际上，所有操作系统都保证了一个进程中虚拟地址从0开始的某个区域是不映射的，其页表项为0。因此访问NULL指针必然触发缺页中断，这时操作系统就可以判断这个地址是否可操作。

补充：另外，windows、linux等操作系统都有一个文件映射技术，可以把一个大小远超过物理内存的文件映射到进程的虚地址空间X起始处，之后程序通过访问数组的方式来访问文件的内容。由于物理内存小于文件大小，所以内核只读入一部分的文件内容，并建立映射，当访问到没有被映射的部分的时候就会触发缺页中断，这个时候中断处理例程会再分配一定的物理内存页面，然后把它映射到访问的地方。这个过程对程序来说是透明的，程序根本不用关心系统物理内存到底有多大。

还可以通过把同一物理页面映射到不同的进程的虚拟地址空间中去来实现内存共享，无论各个进程映射的虚拟地址是相同还是不同的，访问到的都是同一个物理页面。在操作系统中有一个重要的Copy-On-Write机制，多个进程共享同一片内存，这片内存的读写位被设置为0，当某个进程对齐写入的时候，触发中断，在中断出力程序中，把要写入的相关页面复制一份，之后该进程单独使用这些内存，而进程间仍然使用共享的内存。

#### 内存映射的硬件支持
虚地址到物理的转换过程是由硬件自动完成的。由于虚地址映射表是进程私有的，因此各个进程的虚地址映射表被放在不同的物理内存中，而且每个进程都必须把这个表的起始地址告诉MMU，这就是Page Table Start Address的作用，很容易想到这个地址必须是物理地址。

#### 内存的再次优化————二级页表
前面说过虚地址映射表的大小为4MB，在虚地址的高20位是这个表中的索引，这意味着这4MB空间必须作为进程的必备资源在启动的时候一次分配，而且这4MB的内存必须在物理地址上是连续的。这可不是一个好消息，想想内存的设计理念就是在一个小内存系统上运行尽可能多的程序，而这个限制将导致一个配备64M内存的系统运行不了几个进程。考虑到一个进程不需要同时访问到4GB的内存，因此映射表可以被分散开来，像物理内存那样在需要的时候再分配。于是两级、三级甚至4级页表的概念被提出来。

以32位X86系统为例：地址映射表分为两级，第一级被称为页目录表，第二级为页表，每个进程的页目录表起始物理地址由CPU中的寄存器CR3指定，而虚拟地址的最高10位将作为页目录的索引，CR3+（页目录索引*4）就可以得到PDE。PDE的高20位指定一个页表的起始地址，低12位是一些标志位，同时虚拟地址的中间10位被用作页表的索引，从而得到PTE。PTE的高20位指定了一个4KB页面的起始地址，而虚拟地址的最低12位被用作页内偏移量，从而访问到虚拟地址指定的内存单元。最高10位用作页目录的索引，每项4字节，所以页目录大小正好4KB，1024项，每一项指向一个页表，每个页表又有1024项指向对应的4KB页，总共可以映射的内存就是4GB。这样一来，一个进程的页表就可以被分散开来，在页目录索引时，如果发现页表没有被映射，就可以通过缺页中断来分配并建立新的映射。

两级页表虽然能解决一次要连续分配4MB页表的问题，但是每次访问内存都需要两次查表才能得到物理地址，最后才能访问到指定的内存，这样就降低了内存的访问速度，为此CPU内部设置了最近存取的页面的缓存，称为TLB，即程序先到TLB中查找，没有再访问二级页表，从而极大提高访问速度。

#### 内存的继续优化
至此，每一个进程都有独立的页表，进程总是通过查本进程页表来获取物理地址，因此无法直接修改其他进程的内存。这样一来，进程就被保护起来而不受其他进程的影响了。这是保护模式的一个重要特征，但是这样的保护还是不够的。我们知道几乎每一个进程都要通过操作系统提供的接口执行一些操作系统内核提供的代码。例如进程通过read系统调用读取文件内容，而具体读取文件的代码则是操作系统内核提供的，同时内核的这些代码也需要使用一些数据，这部分代码和数据必须映射到每一个进程的地址空间中，但是如果任何一个进程有意或无意地修改了这部分代码或数据的话，后果是很严重的。

### 1.1.2 分段机制
仅仅是分页机制就能够满足虚拟内存管理和保护模式的要求了，现在某些架构的处理器完全不使用分段机制，如MIPS。段机制实际上是x86的一个历史遗留问题，Linux内核也是尽量不使用段机制。Intel在16位处理器时代，由于16位地址线只支持64KB的内存寻址，但是64KB的内存显得太少了。于是提出了分段机制，地址由段基址和偏移组成，用BASE：OFFSET表示，而物理地址由BASE<<4+OFFSET形成。BASE和OFFSET都是16位，OFFSET是段内偏移，因此一个段最多有64KB，而1MB内存最多有16个段，如果使用两个16位的地址分别作为高16位和低16位地址的话，一共是32位，可以最大寻址4GB内存，但是从当时的软硬件条件来看，没有必要这么做。

随着操作系统的发展，提出了保护模式和虚拟内存管理，Intel在分段机制的基础上实现保护模式和虚拟内存管理。后来更为优越的分页机制逐步占据了主流，但是Intel采用分页机制的同时，处于兼容的目的而保留了分段机制。

但此时16位的段寄存器已经不能作为32位系统的段基址，于是段寄存器被用作选择子。而段基址以及段的一些其他属性被存放在一片内存中，被称为段描述符表。为什么不直接将段寄存器也扩充位32位或者更长的呢？因为x86允许不使用分页机制的同时，也能实现保护模式和虚拟内存管理的需要。因此段的基本信息除了段基址外，还需要类似分页机制中页表项中的一些标志位，于是出现了段描述符表。表中的每一项占8字节，它定义了一个段的基本属性。描述符格式如下：
* Segment Base 0-31位表示一个段的起始地址；
* Segment Limit 0-19位表示一个段的最大长度；
* Byte5的最低位A为0，表示本段还从未被访问过，为1表示本段已经被访问过；
* Byte5的ED位表示段的增长方向，ED=0：段地址增长方向是向上的，也就是说从Base开始到Base+Limit这段区间属于本段的。ED=1：段地址增长方向是向下的，也就是说本段的地址空间从Base开始到Base-Limit结束。通常堆栈段是向下增长的；
* Byte5中的E位表示可执行位，当E=1时，表示代码段，E=0表示数据段；
* Byte5中RW为读写位，在数据段中（E=0），RW=0表示该段不能被写入，RW=1表示本段可以被写入；在代码段中，ED=0表示忽略特权级别，ED=1表示遵守特权级别，RW=0，段不可读，RW=1，可读。
* Byte5中的第4位S=1，表示代码段或者数据段，堆栈段也是数据段。S=0，表示系统段，例如终端们，调用门。
* Byte5中的DPL占两位，00～11分别表示访问本段所需要的特权级别，只有级别大于等于DPL中指定的权限才能访问本段。0是最大权限。
* Byte5中的P位表示本段不在内存中，当段内的内存被换入磁盘时可以设置为0，访问这样的段时将触发中断。
* Byte6的第4位保留给系统软件使用。
* Byte6的第5位保留位，总为0。
* Byte6的第6位，DB=0，表示默认地址和操作数是16位，DB=1表示默认地址和操作数是32位。
* Byte6的第7位G=0，表示20位的段界限的单位是字节，这样一个段的最大长度是1M，G=1表示20段界限的单位是4K，这样段的最大长度是4G。

综述：上面许多属性的作用和页表项中重复，实际上在x86上抛开分页机制，也能实现保护模式的各种功能。系统中每一个段都由一个段描述符来表示，这些描述符依次存放在描述符表中，系统中描述符表分全局描述符表和局部描述符表：
* 全局描述符表GDT

CPU内部寄存器GDTR的高32位指向该表的起始地址，低16位表示全局描述符表的界限，界限以字节位单位，低16位可以表示65535个字节，而每一个段描述符表项有8个字节，因此全局描述符表最多有8192项。汇编指令LGDT把一个48位的内存操作数加载到GDTR寄存器中，而SGDT把GDTR保存到一个48位的内存操作数中。

* 局部描述符表LDT

由LDTR寄存器指定。由于Intel的设计本意是每个进程有自己的局部描述符表，因此描述符表的位置不是固定的，它需要随着进程的切换而切换，可能是考虑到进程A切换到进程B的时候，A把自己的LDTR保存在自己的进程地址空间中，之后且还到进程B，再切换回A的时候，由于保护模式下的地址空间隔离，进程B不能恢复A的LDTR，所以进程的LDTR必须保存在全局共享的内存中。于是Intel把每一个局部描述表的首地址放到全局描述表中，这样通过16位的LDTR寄存器在GDT的索引得到一个段描述符表项，改描述符的基地址部分指定了一个局部描述符的起始地址，在这个局部描述符表中又有许多局部描述符表想。其访问过程如下：16位的寄存器LDTR是一个GDT中的索引，实际的LDT由GDT中的一个64位的表项来描述。这样一来每次访问LDT都要查两次表，为了节省开销，LDTR寄存器包含软件可见的16位和软件不可见的64位，LLDT指令的16位操作数作为索引，在GDT中找到64位的一个表项，然后加载到LDTR不可见的部分。

在32位CPU上，段寄存器CS，DS，ES，SS，FS，GS仍然是16位的，被用作全局段描述符和局部段描述符的索引，被称为段选择子，其格式如下：
* 第0位和第1位表示Request Privilege Level，0~3分别代表3个不同的请求级别，最高13位是索引位，可以表示8192项，当TI=1时，表示从局部描述符表选择相应的描述符；TI=0时，从全局描述符表中选择相应的描述符。当CPU通过DS：Offset访问内存的过程是：
1. 如果TI=0，根据GDTR寄存器指定的首地址找到全局描述符表，再利用DS的高13位为索引找到对应的描述符表项，在通过相应的权限检查后，从表项中取出32的段地址，最后再加上Offset从而形成线性地址，如果分页机制开启，该地址还要经过分页机制处理，最后得到物理地址。
2. 如果TI=1，情况类似，先根据GDTR寄存器指定的首地址找到全局描述符表，在利用LDTR的16位软件可见部分作为索引，找到一个表项，然后从该表项中取出32位的基地址，再根据这个基地址找到局部描述符表，然后DS的高13位作为索引在该表中找到一个表项，取出基地址再加上Offset最后得到线性地址。实际上在执行LLDT指令把16位的操作数加载到LDTR软件可见部分的同时，就从这个全局描述表中取出了64位表项加载到LDTR软件不可见部分的缓存中，所以访问的时候就可以根据不可见部分直接找到局部描述符表。

这里段描述符中的DPL和段选择子中的RPL都是用来做权限检查的，段寄存器CS和SS中的RPL是两个特殊的权限级别，他们代表进程的当前权限级别，又被称为CPL。进程在执行指令时，目标操作数的段选择子中的RPL代表请求级别。例如：当前进程的CS和SS中的RPL位为0，它表示进程的当前级别CPL为Ring0，当执行MOV DS:Offset，0这条指令时，操作数DS中的RPL位表示想要获取对该段的访问权限级别，这里假设位1，而DS选择子选中的描述符中那个DPL则代表访问该段所需要的权限，假设为3。这样权限检查的依据是：一个权限位CPL的进程，试图以RPL的权限访问一个要求DPL权限的段。在这个例子中：当前权限为0，试图以权限1的身份，去访问一个最小权限要求为3的段，这个检查是可以通过的。

除此之外，系统中还包括一个特殊的段————任务状态段TSS，任务状态是为硬件级别支持多进程管理而设置的。从CPU的角度来看，进程上下文包括一组cpu寄存器的值，当进程切换的时候，CPU就会把当前进程的寄存器保存在一片内存中，然后把新进程的寄存器从内存中加载到CPU中，这片内存被称为TSS，其格式如下：

每一个进程都有一个TSS段来保存CPU上下文，每一个这样的TSS段也占用GDT中的一个描述表项。描述符的格式如图1.8所示。硬件通过TSS提供进程切换机制，TR寄存器指向当前进程的TSS。当通过段间跳转指令JMP Seg:Offset或者CALL Seg:Offset的时候，如果段寄存器的高13位选择子中的描述符项是一个TSS段的时候，硬件先根据TR寄存器找到当前的TSS，把当前进程上下文保存到TSS中，然后根据JMP或者CALL指令中的段寄存器的选择子找到目标进程的TSS，再把新的TSS加载到CPU中，完成进程切换。在图1.8任务段描述符中，Byte5中的S位为1的时候，表示这是一个系统段描述符，而Byte5的0～3位被称为Type位，表示系统段的类型。10B1表示这是一个TSS段描述符，其中B位为1表示忙。通过为当前正在执行的任务设置忙标志可以避免任务嵌套任务（从任务A切换到任务A本身）。

Type位可以表示如下类型：

| 类型号 |  定义     |
|-------|----------|
| 2     | LDT       |
| 5     | 任务门     |
| A     | 386TSS忙   |
| C     | 386调用门  |
| 2     | 386中断门  |
| 2     | 386陷进门  |

补充：除了SS:ESP外，还有SS0:ESP0，SS1:ESP1，SS2:ESP2这三组堆栈指针，这是为什么？前面说过CPU有4个级别，分别是ring0~ring3，为了避免相互影响，进程在不同级别使用的是独立的堆栈，假设进程从ring3切换到ring0，CPU从TSS中取出SS0:ESP0，同时把ring3的SS:ESP保存在新的ring0的堆栈中，当从ring0返回到ring3的时候，CPU根据ring0堆栈的值恢复ring3的SS:ESP。只有从第级别向高级别切换的时候，才从TSS中取出高级别的堆栈指针，而从高级别向低级别且还的时候，是从高级别的堆栈中恢复第级别的堆栈指针。

### 1.2 系统门
描述符表想中除了段描述符，还有系统段描述符，当段描述符的S位为0时，表示这是一个系统段描述符。系统段描述符包括中断门、陷进门、任务们、调用门。中断门和陷进门用来描述一个中断例程，他们的入口地址依次存放在中断描述表中。

48位的IDTR寄存器的高32位指向这个表，低16位表示该表的界限，lidtr指令用来加载一个48位的操作数到IDTR寄存器。中断门和陷阱门描述：前16位的选择子和32位的Offset偏移地址指定了一个中断处理例程的地址。Type指示了门的类型，陷阱门和中断门类似，外部中断的处理例程的描述符项被称为中断门，而异常处理例程的描述符则被称为陷阱门。严格来说，中断是由外部设备向CPU发出的，CPU经过地址译码、取指令，指令译码，指令执行等流水步骤，在最后会检查CPU中断请求先是否有信号，所以中断是一个异步事件，CPU在执行指令期间，外部设备随时可以发出中断请求。而异常是一个同步事件，比如除0错误，是CPU在指令期触发的。

当发生中断/异常时，CPU利用中断/异常号得到中断向量表中索引得到门描述符，然后调用描述符指定的处理例程。

### 1.3 调用门
Reserve字段用来表示Param Count，参数个数。调用门可以实现低级别的权限向高级别权限切换，也可以用来实现系统调用。前面说过，不同权限使用不同的堆栈，而系统调用时，如果需要传递参数的话，就需要把当前低级别要传递的参数拷贝到高级别的堆栈中取，而Param Count指定了拷贝参数的数量。当执行CALL Seg:Offset或者JMP Seg:Offset等转移指令的时候，如果段选择子选中的是一个调用门，CPU会转向调用门指定的入口地址。

注：调用门实际上没有被使用。Linux的系统调用通过int 0x80来实现，这是一个陷阱门。

### 1.4 任务门
实现任务切换，注意描述的任务描述符是段描述的一种，可以通过它实现任务切换，而这里的任务门是门描述符的一种。

任务们的16位TSS Selector是TSS Selector是TSS段选择子，当CALL，JMP或者IRET等转移指令执行的时候，如果转移目标Seg:Offset指向的是一个任务门，CPU将从任务门中取出16位的选择子，然后利用这个选择子的高13位作为全局描述符表的索引，找到对应的任务段描述符，然后从中取出任务状态段TSS的地址，最后切换到该TSS指定的任务。任务们在实际中也没有使用。

### 1.5 x86的寄存器
x86包含32位的通用寄存器EAX、EBX、ECX、EDX、EBP、ESP、ESI、EDI；16位的段寄存器CS、DS、SS、ES、FS、GS；32位的标志寄存器EFLAGS；32位的指令指针寄存器EIP；32位的控制寄存器CR0，CR1，CR2，CR3；48位的全局描述符寄存器GTDR，中断描述符表寄存器IDTR；16位的局部描述符表寄存器LDTR，任务状态描述符TR，32位的调试寄存器DR0～DR7.

CR0控制寄存器：
* 第0位是保护模式允许位(Protection Enable)，当PE为1的时候CPU进入保护模式，PE为0时CPU工作在实模式。
* 第1位是协处理器监控位(Monitor Coprocessor)，MP=1表示有协处理器，MP=0表示没有
* 第二位是模拟协处理器位，当没有协处理器时，CPU如果遇到浮点指令，产生协处理器无效中断，中断例程将用软件方式模拟协处理器。
* 第三位是任务转换位，当任务转换完成后该位被置1.
* 第4位是处理器扩展类型控制位，为1表示协处理器是32位的80387，0表示是16位的80287
* 最高位是分页允许位，1表示开启分页机制，0表示关闭分页机制

CR1 保留

CR2是异常线性地址寄存器。当CPU访问一个内存地址时，如果该地址没有对应的物理页面被映射到页表中，那么会触发缺页异常，同时CPU会把这个内存地址放到CR2中，这样异步处理程序就可以进一步处理异常。

CR3寄存器的高20位用来保存页目录基地址，不同进程拥有不同的地址空间，就是通过切换CR3来实现的。

####调试寄存器
DR0～DR3：四个内存断点寄存器

DR4，DR5保留

DR6是断点状态寄存器

DR7是断点控制标志寄存器

CPU每次执行内存相关的指令时会检测DR7的标志，然后把相关指令的地址和DR0～DR3做比较，如果相等，则触发调试异常，DR7中规定对相关地址的监控要求，比如是读还是写，是一个字节、两个字节或者4个字节。如果DR0=X，当DR7中规定读监控两个字节时，CPU读取X+1也会触发异常。

#### 标记寄存器EFLAGS
* 第12、13位IOPL是特权指令许可位，当执行IN、OUT、CLI等IO指令的时候，CPU会比较指令段寄存器CS中的CPL，只有CPL大于IOPL时，IO指令才能正确执行。
* 第17位VM是虚拟8086位，如果该位被设置，CPU工作在虚拟8086模式下。

### 1.6 典型的PC系统结构简介
典型的PC系统：北桥主要控制相对高速的设备，而南桥控制速度相对较低的IO设备。南/北桥上有大量的配置寄存器，例如北桥上面的某个寄存器可以配置内存的起始地址和结束地址，由于外部设备也有板载存储空间，因此当CPU从地址总线发出一个寻址请求时，北桥会根据配置寄存器确定这个地址落在内存的存储空间中，还是南桥上面的外部设备的存储空间中，从而正确寻址。

这是理解外部设备的基地址配置的基础。例如：把地址X写入到某个PCI设备的基地址寄存器后，当CPU发出对X的寻址请求时，北桥芯片经过比较判断这个地址落在PCI地址空间，于是寻址请求转发到南桥，同样南桥再转发到PCI总线，PCI总线上的各个PCI设备芯片都会把总线上的地址和基址寄存器中的值进行比较，只有相匹配的设备才会做出应答。 如果某些新的CPU它的内存控制器集成在CPU中，那么CPU内部有相同的判断。

通常32位地址总线的系统支持的最大物理内存是4GB，其实这4GB指的是内存地址空间，所以系统中支持的内存肯定不能是4GB，因为一部分地址空间需要留给外部设备的板载内存。而4GB的内存限制对很多服务器来说是不够的，所以Intel将地址总线扩充到36位，被称为PAE。

在南桥中集成了大量的IO设备县官的控制器。
